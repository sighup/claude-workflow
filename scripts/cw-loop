#!/bin/bash
#
# cw-loop - Autonomous execution loop for Claude Workflow
#
# Orchestrates task execution by reading task state directly from
# ~/.claude/tasks and invoking Claude to execute tasks until complete.
#
# Usage:
#   ./cw-loop [OPTIONS] [PROJECT_PATH]
#
# Options:
#   -m, --model MODEL     Claude model to use (default: sonnet)
#   -n, --max-iter N      Maximum iterations (default: 50)
#   -s, --sleep N         Seconds between iterations (default: 5)
#   -d, --dispatch        Use cw-dispatch for parallel execution (default: cw-execute)
#   -h, --help            Show this help message
#
# Arguments:
#   PROJECT_PATH          Project directory (default: current directory)
#
# Environment Variables:
#   CW_MODEL              Claude model (default: sonnet)
#   CW_MAX_ITERATIONS     Maximum iterations (default: 50)
#   CW_SLEEP              Seconds between iterations (default: 5)
#   CW_MAX_FAILURES       Max consecutive failures before abort (default: 3)
#   CW_TIMEOUT            Claude invocation timeout in seconds (default: 0/none)
#   CW_NON_INTERACTIVE    Skip confirmation prompt if "true"
#

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib/cw-common.sh"

# =============================================================================
# Argument Parsing
# =============================================================================

USE_DISPATCH=false
PROJECT_PATH=""

show_help() {
    echo "Usage: cw-loop [OPTIONS] [PROJECT_PATH]"
    echo ""
    echo "Autonomous execution loop for Claude Workflow tasks."
    echo "Reads task state directly from ~/.claude/tasks (no manifest needed)."
    echo ""
    echo "Options:"
    echo "  -m, --model MODEL     Claude model (default: $CW_MODEL)"
    echo "  -n, --max-iter N      Maximum iterations (default: $CW_MAX_ITERATIONS)"
    echo "  -s, --sleep N         Seconds between iterations (default: $CW_SLEEP)"
    echo "  -d, --dispatch        Use cw-dispatch for parallel execution"
    echo "  -h, --help            Show this help"
    echo ""
    echo "Arguments:"
    echo "  PROJECT_PATH          Project directory (default: current directory)"
    echo ""
    echo "Environment Variables:"
    echo "  CW_MODEL, CW_MAX_ITERATIONS, CW_SLEEP, CW_MAX_FAILURES, CW_TIMEOUT"
    echo ""
    echo "Exit Codes:"
    echo "  0  All tasks completed successfully"
    echo "  1  Max iterations exhausted"
    echo "  2  Max consecutive failures reached"
    echo "  3  No available tasks (all blocked)"
    echo "  4  Missing dependencies or no session found"
}

while [[ $# -gt 0 ]]; do
    case $1 in
        -m|--model) CW_MODEL="$2"; shift 2 ;;
        -n|--max-iter) CW_MAX_ITERATIONS="$2"; shift 2 ;;
        -s|--sleep) CW_SLEEP="$2"; shift 2 ;;
        -d|--dispatch) USE_DISPATCH=true; shift ;;
        -h|--help) show_help; exit 0 ;;
        -*) log_error "Unknown option: $1"; show_help; exit 4 ;;
        *) PROJECT_PATH="$1"; shift ;;
    esac
done

# Default to current directory
PROJECT_PATH="${PROJECT_PATH:-$(pwd)}"

# =============================================================================
# Preflight Checks
# =============================================================================

check_jq || exit 4
check_claude || exit 4

print_banner "Claude Workflow - Autonomous Loop"

log_info "Project: $PROJECT_PATH"
log_info "Model: $CW_MODEL"
log_info "Max iterations: $CW_MAX_ITERATIONS"
log_info "Sleep between: ${CW_SLEEP}s"
log_info "Max failures: $CW_MAX_FAILURES"
log_info "Mode: $([ "$USE_DISPATCH" = true ] && echo "dispatch (parallel)" || echo "execute (sequential)")"

# =============================================================================
# Session Discovery
# =============================================================================

log_header "Discovering session"

if ! discover_session "$PROJECT_PATH"; then
    log_error "No session with tasks found."
    log_info "Run '/cw-plan' first to create tasks from a spec."
    exit 4
fi

print_task_status
show_task_list

# Confirm before starting
if [ "${CW_NON_INTERACTIVE}" != "true" ]; then
    echo ""
    echo -e "${YELLOW}Ready to start autonomous execution.${NC}"
    echo "Press Enter to continue or Ctrl+C to cancel..."
    read -r
fi

# =============================================================================
# Main Loop
# =============================================================================

ITERATION=0
FAILURES=0
START_TIME=$(date +%s)

# Select skill based on mode
if [ "$USE_DISPATCH" = true ]; then
    SKILL_NAME="cw-dispatch"
    SKILL_PROMPT="Use the Skill tool to invoke 'cw-dispatch'. Execute available tasks in parallel from the task board."
else
    SKILL_NAME="cw-execute"
    SKILL_PROMPT="Use the Skill tool to invoke 'cw-execute'. Execute the next available task from the task board."
fi

while [ $ITERATION -lt $CW_MAX_ITERATIONS ]; do
    ITERATION=$((ITERATION + 1))

    ELAPSED=$(($(date +%s) - START_TIME))
    log_header "Iteration $ITERATION / $CW_MAX_ITERATIONS  [Runtime: $(format_elapsed $ELAPSED)]"

    # Check completion (reads directly from task files)
    if is_complete; then
        ELAPSED=$(($(date +%s) - START_TIME))
        log_success "All tasks completed! (Runtime: $(format_elapsed $ELAPSED))"
        print_task_status
        exit 0
    fi

    # Check for available work
    PENDING=$(get_pending_count)
    if [ "$PENDING" -eq 0 ]; then
        ELAPSED=$(($(date +%s) - START_TIME))
        log_warning "No unblocked pending tasks available. (Runtime: $(format_elapsed $ELAPSED))"
        print_task_status
        exit 3
    fi

    NEXT=$(get_next_task_id)
    log_info "Next task: $NEXT ($PENDING pending unblocked)"

    # Capture completed count before execution
    COMPLETED_BEFORE=$(get_completed_count)

    # Execute task(s)
    log_info "Invoking Claude with $SKILL_NAME..."
    if invoke_claude "$SKILL_PROMPT" "$CW_MODEL"; then
        log_success "Execution completed"
        FAILURES=0

        # Verify task progress was recorded
        COMPLETED_AFTER=$(get_completed_count)
        if [ "$COMPLETED_AFTER" -eq "$COMPLETED_BEFORE" ]; then
            log_warning "No tasks were marked completed. Worker may have bypassed cw-execute."
            log_warning "Check that workers invoke the Skill tool with 'cw-execute'."
        else
            NEWLY_DONE=$((COMPLETED_AFTER - COMPLETED_BEFORE))
            log_info "Tasks completed this iteration: $NEWLY_DONE"
        fi
    else
        FAILURES=$((FAILURES + 1))
        log_error "Execution failed (failure $FAILURES/$CW_MAX_FAILURES)"

        if [ $FAILURES -ge $CW_MAX_FAILURES ]; then
            ELAPSED=$(($(date +%s) - START_TIME))
            log_error "Max consecutive failures reached. Aborting. (Runtime: $(format_elapsed $ELAPSED))"
            print_task_status
            exit 2
        fi
    fi

    # Show current status
    print_task_status

    # Sleep between iterations
    if [ $ITERATION -lt $CW_MAX_ITERATIONS ]; then
        log_info "Sleeping ${CW_SLEEP}s before next iteration..."
        sleep "$CW_SLEEP"
    fi
done

ELAPSED=$(($(date +%s) - START_TIME))
log_warning "Max iterations ($CW_MAX_ITERATIONS) exhausted. (Runtime: $(format_elapsed $ELAPSED))"
print_task_status
exit 1
